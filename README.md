# 基于物联网的视频系统——使用说明书

### 软件设计思路
考虑到是基于物联网的视频系统，在生产环境中必然存在网络不稳定，带宽有限制的情况，所以传统的端口转发不能适应其网络环境。

于是我们想到了采集端收集到的视频可以经过处理，再以图片的形式发给服务端，并配合帧率检测处理，帧率变化大的时候发送频率快，帧率变化小的时候发送频率较慢。然后在服务端进行连接、复原成能播放的视频流。

### 架构设计思路
##### 采集端：树莓派3b+、海康威视网络摄像头
##### 服务端：服务器
##### 开发语言：C++


采集端软件运行在树莓派上，树莓派与海康威视摄像头处于同一内网中（可用网线直接连接）。

树莓派获取到海康威视摄像头的rstp流后进行处理，并分割、封装成大小相同的udp包，向服务器端传输。

服务器端受到包后，重新连接，处理，并以mp4格式写入文件。

### UDP自定义应用层说明
udp应用层采用一个结构体。

我们每一次用opencv::Mat这个数据结构保存从网络摄像头读来的每一帧画面，并分一条线程进行入队处理。理想情况是直接传输完整的Mat，然而实际上socket UDP一次只能传输65535字节的char\*型数据。

我们的摄像头获取到的是1980\*1080大小的Mat，远远超过了这个大小。再者，一次性传输过大的数据也不满足物联网生产环境网络不稳定的要求，所以我们考虑把Mat型数据分割为等长的“小包”，把这些“小包”发送给服务端后再连接成为“大包”。

很显然，我们必须对每一个小包进行标志处理，否则我们无法分辨出这个“小包”在原来Mat型“大包”中的位置，我们定义了一个结构体，对每一个“小包”来说，它们有以下的标识：

- flag：判断“小包”是原“大包”的包头（flag=0）、包腹（flag=1）、还是包尾（flag=2）。
- pack_len：这个“小包”所在的大包里，总的“小包”的个数。
- pack_id：第几个“小包”。
- encode[EACH_PACK]：真正装有图像数据的容器。

我们先使用opencv中的函数：cv::imencode，将Mat编码，并装入std::vector<uchar>容器里。

我们每一次 memcpy 从buf_all[0]地址开始，EACH_PACK大小的数据到我们的buf中（除最后一次可能小于EACH_PACK）。


### 依赖的外部软件包
opencv

### 安装配置说明
安装阶段:

	联网配置时：
	sudo 运行 conf.sh，自动化配置环境
	运行makefile，自动编译
	可执行文件在build文件夹里
	client为客户端程序
	server为服务端程序


用法:
客户端：
chmod 777 clnstart.sh
./clnstart.sh

服务端：
chmod 777 sevstart.sh
./sevstart.sh

按要求输入参数即可

